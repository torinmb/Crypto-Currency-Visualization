<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - interactive cubes (gpu)</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}

			.info {
				position: absolute;
				background-color: black;
				opacity: 0.8;
				color: white;
				text-align: center;
				top: 0px;
				width: 100%;
			}

			.info a {
				color: #00ffff;
			}
		</style>
	</head>
	<body>

		<div class="info">
			<a href="http://threejs.org" target="_blank">three.js</a> webgl - gpu picking
		</div>

		<div id="container"></div>

		<script src="build/three.min.js"></script>

		<script src="js/controls/TrackballControls.js"></script>

		<script src="js/libs/stats.min.js"></script>
		<script src="js/shaders/BleachBypassShader.js"></script>
		<script src="js/shaders/ConvolutionShader.js"></script>
		<script src="js/shaders/CopyShader.js"></script>
		<script src="js/shaders/HorizontalTiltShiftShader.js"></script>
		<script src="js/shaders/LuminosityShader.js"></script>
		<script src="js/shaders/NormalMapShader.js"></script>
		<script src="js/shaders/VerticalTiltShiftShader.js"></script>

		<script src="js/postprocessing/EffectComposer.js"></script>
		<script src="js/postprocessing/RenderPass.js"></script>
		<script src="js/postprocessing/BloomPass.js"></script>
		<script src="js/postprocessing/ShaderPass.js"></script>
		<script src="js/postprocessing/MaskPass.js"></script>
		<script src="js/postprocessing/SavePass.js"></script>
		<script src="js/ShaderTerrain.js"></script>
		<script src="js/improvedNoise.js"></script>
		<script src="js/loaders/DDSLoader.js"></script>

		<script id="fragmentShaderNoise" type="x-shader/x-fragment">


			//
			// Description : Array and textureless GLSL 3D simplex noise function.
			//      Author : Ian McEwan, Ashima Arts.
			//  Maintainer : ijm
			//     Lastmod : 20110409 (stegu)
			//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
			//               Distributed under the MIT License. See LICENSE file.
			//

			uniform float time;
			varying vec2 vUv;

			vec4 permute( vec4 x ) {

				return mod( ( ( x * 34.0 ) + 1.0 ) * x, 289.0 );

			}

			vec4 taylorInvSqrt( vec4 r ) {

				return 1.79284291400159 - 0.85373472095314 * r;

			}

			float snoise( vec3 v ) {

				const vec2 C = vec2( 1.0 / 6.0, 1.0 / 3.0 );
				const vec4 D = vec4( 0.0, 0.5, 1.0, 2.0 );

				// First corner

				vec3 i  = floor( v + dot( v, C.yyy ) );
				vec3 x0 = v - i + dot( i, C.xxx );

				// Other corners

				vec3 g = step( x0.yzx, x0.xyz );
				vec3 l = 1.0 - g;
				vec3 i1 = min( g.xyz, l.zxy );
				vec3 i2 = max( g.xyz, l.zxy );

				vec3 x1 = x0 - i1 + 1.0 * C.xxx;
				vec3 x2 = x0 - i2 + 2.0 * C.xxx;
				vec3 x3 = x0 - 1. + 3.0 * C.xxx;

				// Permutations

				i = mod( i, 289.0 );
				vec4 p = permute( permute( permute(
						 i.z + vec4( 0.0, i1.z, i2.z, 1.0 ) )
					   + i.y + vec4( 0.0, i1.y, i2.y, 1.0 ) )
					   + i.x + vec4( 0.0, i1.x, i2.x, 1.0 ) );

				// Gradients
				// ( N*N points uniformly over a square, mapped onto an octahedron.)

				float n_ = 1.0 / 7.0; // N=7

				vec3 ns = n_ * D.wyz - D.xzx;

				vec4 j = p - 49.0 * floor( p * ns.z *ns.z );  //  mod(p,N*N)

				vec4 x_ = floor( j * ns.z );
				vec4 y_ = floor( j - 7.0 * x_ );    // mod(j,N)

				vec4 x = x_ *ns.x + ns.yyyy;
				vec4 y = y_ *ns.x + ns.yyyy;
				vec4 h = 1.0 - abs( x ) - abs( y );

				vec4 b0 = vec4( x.xy, y.xy );
				vec4 b1 = vec4( x.zw, y.zw );


				vec4 s0 = floor( b0 ) * 2.0 + 1.0;
				vec4 s1 = floor( b1 ) * 2.0 + 1.0;
				vec4 sh = -step( h, vec4( 0.0 ) );

				vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
				vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;

				vec3 p0 = vec3( a0.xy, h.x );
				vec3 p1 = vec3( a0.zw, h.y );
				vec3 p2 = vec3( a1.xy, h.z );
				vec3 p3 = vec3( a1.zw, h.w );

				// Normalise gradients

				vec4 norm = taylorInvSqrt( vec4( dot( p0, p0 ), dot( p1, p1 ), dot( p2, p2 ), dot( p3, p3 ) ) );
				p0 *= norm.x;
				p1 *= norm.y;
				p2 *= norm.z;
				p3 *= norm.w;

				// Mix final noise value

				vec4 m = max( 0.6 - vec4( dot( x0, x0 ), dot( x1, x1 ), dot( x2, x2 ), dot( x3, x3 ) ), 0.0 );
				m = m * m;
				return 42.0 * dot( m*m, vec4( dot( p0, x0 ), dot( p1, x1 ),
											  dot( p2, x2 ), dot( p3, x3 ) ) );

			}

			float surface3( vec3 coord ) {

				float n = 0.0;

				n += 1.0 * abs( snoise( coord ) );
				n += 0.5 * abs( snoise( coord * 2.0 ) );
				n += 0.25 * abs( snoise( coord * 4.0 ) );
				n += 0.125 * abs( snoise( coord * 8.0 ) );

				return n;

			}

			void main( void ) {

				vec3 coord = vec3( vUv, -time );
				float n = surface3( coord );

				gl_FragColor = vec4( vec3( n, n, n ), 1.0 );

			}

		</script>

		<script id="vertexShader" type="x-shader/x-vertex">

			varying vec2 vUv;
			uniform vec2 scale;
			uniform vec2 offset;

			void main( void ) {

				vUv = uv * scale + offset;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			}

		</script>		

		<script>
			var cellSize, columns, rows;
			var container, stats;
			var camera, controls, scene, renderer;
			var pickingData = [], pickingTexture, pickingScene;
			var objects = [];
			var highlightBox;
			var SCREEN_WIDTH = window.innerWidth;
			var SCREEN_HEIGHT = window.innerHeight;

			//Tiltshift
			var cameraOrtho, sceneRenderTarget;
			var clock = new THREE.Clock();
			var uniformsNoise, uniformsNormal,
				heightMap, normalMap,
				quadTarget;

			var animDelta = 0, animDeltaDir = -1;
			var lightVal = 0, lightDir = 1;


			var mouse = new THREE.Vector2();
			var offset = new THREE.Vector3( 10, 10, 10 );

			//Tiltshift
			

			init();
			animate();

			function init() {

				container = document.getElementById( "container" );
				// SCENE (RENDER TARGET)

				sceneRenderTarget = new THREE.Scene();
				cameraOrtho = new THREE.OrthographicCamera( SCREEN_WIDTH / - 2, SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2, SCREEN_HEIGHT / - 2, -10000, 10000 );
				cameraOrtho.position.z = 100;
				sceneRenderTarget.add( cameraOrtho );

				//Scene Final
				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = 1000;


				controls = new THREE.TrackballControls( camera );
				controls.rotateSpeed = 1.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 0.8;
				controls.noZoom = false;
				controls.noPan = false;
				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;

				scene = new THREE.Scene();
				scene.fog = new THREE.Fog( 0x050505, 2000, 50000 );

				pickingScene = new THREE.Scene();
				pickingTexture = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight );
				pickingTexture.generateMipmaps = false;

				// LIGHTS

				scene.add( new THREE.AmbientLight( 0x111111 ) );

				directionalLight = new THREE.DirectionalLight( 0xffffff, 1.15 );
				directionalLight.position.set( 500, 2000, 0 );
				scene.add( directionalLight );

				pointLight = new THREE.PointLight( 0xff4400, 1.5 );
				pointLight.position.set( 0, 0, 0 );
				scene.add( pointLight );

				// HEIGHT + NORMAL MAPS

				var normalShader = THREE.NormalMapShader;

				var rx = 256, ry = 256;
				var pars = { minFilter: THREE.LinearMipmapLinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat };

				heightMap  = new THREE.WebGLRenderTarget( rx, ry, pars );
				heightMap.generateMipmaps = false;

				normalMap = new THREE.WebGLRenderTarget( rx, ry, pars );
				normalMap.generateMipmaps = false;

				uniformsNoise = {

					time:   { type: "f", value: 1.0 },
					scale:  { type: "v2", value: new THREE.Vector2( 1.5, 1.5 ) },
					offset: { type: "v2", value: new THREE.Vector2( 0, 0 ) }

				};

				uniformsNormal = THREE.UniformsUtils.clone( normalShader.uniforms );

				uniformsNormal.height.value = 0.05;
				uniformsNormal.resolution.value.set( rx, ry );
				uniformsNormal.heightMap.value = heightMap;

				var vertexShader = document.getElementById( 'vertexShader' ).textContent;
				//Custom box look
				var loader = new THREE.DDSLoader();
				var map1 = loader.load( 'textures/compressed/disturb_argb_mip.dds' );
				map1.minFilter = map1.magFilter = THREE.LinearFilter;
				map1.anisotropy = 4;
				var cubemap1 = loader.load( 'textures/compressed/Mountains_argb_mip.dds', function ( texture ) {
					texture.magFilter = THREE.LinearFilter
					texture.minFilter = THREE.LinearMipmapLinearFilter;
					texture.mapping = new THREE.CubeReflectionMapping();

					// defaultMaterial.needsUpdate = true;
				} );


				var geometry = new THREE.Geometry(),
				pickingGeometry = new THREE.Geometry(),
				pickingMaterial = new THREE.MeshBasicMaterial( { vertexColors: THREE.VertexColors } ),
				defaultMaterial = new THREE.MeshBasicMaterial( {envMap: cubemap1, vertexColors: THREE.VertexColors } );
				defaultMaterial.castShadow = true;
				defaultMaterial.receiveShadow = true;
				defaultMaterial.needsUpdate = true;
				function applyVertexColors( g, c ) {

					g.faces.forEach( function( f ) {

						var n = ( f instanceof THREE.Face3 ) ? 3 : 4;

						for( var j = 0; j < n; j ++ ) {

							f.vertexColors[ j ] = c;

						}

					} );

				}
				var color = new THREE.Color();

				var matrix = new THREE.Matrix4();
				var quaternion = new THREE.Quaternion();
				var noiseGen = new ImprovedNoise();

				var height =2;
				var width = 0;

				cellSize = 100;
				columns = 140;
				rows = 100;
				for ( var i = 0; i < columns; i ++ ) {
					for (var j = 0; j < rows; j++) {


						var add = Math.sqrt(i*i + j*j);
						var equation = noiseGen.noise(i * j *.02, j*.02, add*.02)
						height = Math.abs(2000 * equation);
						var geom = new THREE.BoxGeometry(cellSize, height , cellSize);
						// var geom = new THREE.CylinderGeometry( 0, cellSize, height, 3 );
						// geom.applyMatrix( new THREE.Matrix4().makeRotationFromEuler( new THREE.Euler( 0, 0, 0 ) ) );

						var position = new THREE.Vector3();
						position.x = (i * cellSize + cellSize / 2) - (columns * cellSize /2);
						position.y = height / 2;
						position.z = (j * cellSize + cellSize / 2) - (rows * cellSize /2);
						width = position.x + cellSize;
						
						var t = Math.PI * ((i + j) * 1.0) / (columns + rows);
						var u = 2 * Math.PI * ((i + j) * 1.0) / (columns + rows);
						var rotation = new THREE.Euler();
						// position.x = Math.sin(t)*Math.sin(u) *cellSize*20;
						// position.y = Math.sin(t) * Math.cos(u)* cellSize*20;
						// position.z = Math.cos(t)* cellSize*20;
						// rotation.x = position.x;
						// rotation.y = position.y;
						// rotation.z = position.z;
						// rotation.x = 20*Math.PI*(i)/(rows);
						// rotation.y = 20*Math.PI*(i)/(columns);
						// rotation.z = 20*Math.PI*(i+j)/(rows + columns);
						// rotation.x = 10*Math.PI*equation;
						// rotation.y = 10*Math.PI*equation;
						// rotation.z = 10*Math.PI*equation;
// 
						var scale = new THREE.Vector3();
						scale.x = 1;
						scale.y = 1;
						scale.z = 1;

						quaternion.setFromEuler( rotation, false );
						matrix.compose( position, quaternion, scale );

						// give the geom's vertices a random color, to be displayed

						// applyVertexColors( geom, color.setHex( Math.abs(height/800) * 0xffffff ) );
						var c = Math.abs(height/1500); 
						applyVertexColors( geom, color.setHSL(c, 1, 1-c) );

						geometry.merge( geom, matrix );

						// give the geom's vertices a color corresponding to the "id"

						applyVertexColors( geom, color.setHex( i ) );

						pickingGeometry.merge( geom, matrix );

						pickingData[ i ] = {

							position: position,
							rotation: rotation
							// scale: scale

						};
					};

				}

				var drawnObject = new THREE.Mesh( geometry, defaultMaterial );
				scene.add( drawnObject );
				// geometry.position.set(width, 0, width);
				
				// var drawnObject2 = new THREE.Mesh( geometry, defaultMaterial );
				// scene.add( drawnObject2 );

				// pickingScene.add( new THREE.Mesh( pickingGeometry, pickingMaterial ) );

				highlightBox = new THREE.Mesh(
					new THREE.BoxGeometry( 1, 1, 1 ),
					new THREE.MeshLambertMaterial( { color: 0xffff00 }
				) );
				scene.add( highlightBox );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setClearColor( 0xffffff, 1 );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.sortObjects = false;
				container.appendChild( renderer.domElement );
				renderer.gammaInput = true;
				renderer.gammaOutput = true;

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				renderer.domElement.addEventListener( 'mousemove', onMouseMove );
				document.addEventListener( 'keydown', onKeyDown, false );

				// COMPOSER

				renderer.autoClear = false;

				renderTargetParameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat, stencilBuffer: false };

				renderTarget = new THREE.WebGLRenderTarget( SCREEN_WIDTH, SCREEN_HEIGHT, renderTargetParameters );
				renderTarget.generateMipmaps = false;

				effectBloom = new THREE.BloomPass( 0.6 );
				var effectBleach = new THREE.ShaderPass( THREE.BleachBypassShader );

				hblur = new THREE.ShaderPass( THREE.HorizontalTiltShiftShader );
				vblur = new THREE.ShaderPass( THREE.VerticalTiltShiftShader );

				var bluriness = 6;

				hblur.uniforms[ 'h' ].value = bluriness / SCREEN_WIDTH;
				vblur.uniforms[ 'v' ].value = bluriness / SCREEN_HEIGHT;

				hblur.uniforms[ 'r' ].value = vblur.uniforms[ 'r' ].value = 0.5;

				effectBleach.uniforms[ 'opacity' ].value = 0.65;

				composer = new THREE.EffectComposer( renderer, renderTarget );

				var renderModel = new THREE.RenderPass( scene, camera );

				vblur.renderToScreen = true;

				composer = new THREE.EffectComposer( renderer, renderTarget );

				composer.addPass( renderModel );

				composer.addPass( effectBloom );
				//composer.addPass( effectBleach );

				composer.addPass( hblur );
				composer.addPass( vblur );

			}
			
			function applyShader( shader, texture, target ) {

				var shaderMaterial = new THREE.ShaderMaterial( {

					fragmentShader: shader.fragmentShader,
					vertexShader: shader.vertexShader,
					uniforms: THREE.UniformsUtils.clone( shader.uniforms )

				} );

				shaderMaterial.uniforms[ "tDiffuse" ].value = texture;

				var sceneTmp = new THREE.Scene();

				var meshTmp = new THREE.Mesh( new THREE.PlaneGeometry( SCREEN_WIDTH, SCREEN_HEIGHT ), shaderMaterial );
				meshTmp.position.z = -500;

				sceneTmp.add( meshTmp );

				renderer.render( sceneTmp, cameraOrtho, target, true );

			};
			function onKeyDown ( event ) {

				switch( event.keyCode ) {

					case 78: /*N*/  lightDir *= -1; break;
					case 77: /*M*/  animDeltaDir *= -1; break;

				}

			};

			function onMouseMove( e ) {

				mouse.x = e.clientX;
				mouse.y = e.clientY;

			}

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function pick() {

				//render the picking scene off-screen

				renderer.render( pickingScene, camera, pickingTexture );

				var gl = self.renderer.getContext();

				//read the pixel under the mouse from the texture

				var pixelBuffer = new Uint8Array( 4 );
				gl.readPixels( mouse.x, pickingTexture.height - mouse.y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixelBuffer );

				//interpret the pixel as an ID

				var id = ( pixelBuffer[0] << 16 ) | ( pixelBuffer[1] << 8 ) | ( pixelBuffer[2] );
				var data = pickingData[ id ];

				if ( data) {

					//move our highlightBox so that it surrounds the picked object

					if ( data.position && data.rotation && data.scale ){

						highlightBox.position.copy( data.position );
						highlightBox.rotation.copy( data.rotation );
						highlightBox.scale.copy( data.scale ).add( offset );
						highlightBox.visible = true;
					}

				} else {

					highlightBox.visible = false;

				}

			}

			function render() {
				var delta = clock.getDelta();
				controls.update();

				pick();


				var fLow = 0.1, fHigh = 0.8;

				lightVal = THREE.Math.clamp( lightVal + 0.5 * delta * lightDir, fLow, fHigh );

				var valNorm = ( lightVal - fLow ) / ( fHigh - fLow );

				scene.fog.color.setHSL( 0.1, 0.5, lightVal );

				renderer.setClearColor( scene.fog.color, 1 );

				directionalLight.intensity = THREE.Math.mapLinear( valNorm, 0, 1, 0.1, 1.15 );
				pointLight.intensity = THREE.Math.mapLinear( valNorm, 0, 1, 0.9, 1.5 );
				if (animDeltaDir != -1){ 
					for ( var i = 1, l = scene.children.length; i < l; i ++ ) {

						scene.children[ i ].lookAt( camera.position );

					}
				}

				composer.render( 0.1 );
				// renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
